class Vector {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  copy() {
    return new Vector(this.x, this.y);
  }

  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }

  add(v) {
    this.x = this.x + v.x;
    this.y = this.y + v.y;
    return this;
  }

  sub(v) {
    this.x = this.x - v.x;
    this.y = this.y - v.y;
    return this;
  }

  mult(n) {
    this.x = this.x * n;
    this.y = this.y * n;
    return this;
  }

  div(n) {
    this.x = this.x / n;
    this.y = this.y / n;
    return this;
  }

  lerp(v, t) {
    this.x += (v.x - this.x) * t;
    this.y += (v.y - this.y) * t;
    return this;
  }

  normalize() {
    const m = this.mag();
    if (m !== 0 && m !== 1) {
      this.div(m);
    }
    return this;
  }

  setMag(n) {
    const m = this.mag();
    if (m !== 0) this.mult(n / m);
    return this;
  }

  limit(max) {
    const m2 = this.magSq();
    const max2 = max * max;
    if (m2 > max2) this.setMag(max);
    return this;
  }

  rotate(theta) {
    const { x, y } = this;
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.x = x * c - y * s;
    this.y = x * s + y * c;
    return this;
  }
  rotateAround(p, theta) {
    const x = this.x - p.x,
      y = this.y - p.y;
    const c = Math.cos(theta),
      s = Math.sin(theta);
    this.x = p.x + x * c - y * s;
    this.y = p.y + x * s + y * c;
    return this;
  }

  mag() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  magSq() {
    return this.x * this.x + this.y * this.y;
  }

  dist(v) {
    const x = this.x - v.x;
    const y = this.y - v.y;
    return Math.sqrt(x * x + y * y);
  }

  heading() {
    return Math.atan2(this.y, this.x);
  }

  angleTo(v) {
    const m1 = this.mag();
    const m2 = v.mag();
    if (m1 === 0 || m2 === 0) return 0;
    let amt = this.dot(v) / (m1 * m2);
    amt = Math.min(1, Math.max(-1, amt));
    return Math.acos(amt);
  }
  signedAngleTo(v) {
    const dot = this.dot(v);
    const cross = this.cross(v);
    return Math.atan2(cross, dot);
  }

  dot(v) {
    return this.x * v.x + this.y * v.y;
  }

  cross(v) {
    return this.x * v.y - this.y * v.x;
  }

  signTo(v) {
    return Math.sign(this.x * v.y - this.y * v.x);
  }

  scalarProject(v) {
    const m = v.mag();
    if (m === 0) return 0;
    return this.dot(v) / m;
  }
  project(v) {
    const m2 = v.mag() ** 2;
    if (m2 === 0) return this.set(0, 0);
    const scalar = this.dot(v) / m2;
    this.x = v.x * scalar;
    this.y = v.y * scalar;
    return this;
  }

  perp() {
    return new Vector(-this.y, this.x);
  }
  perpTo(target, { right = false, length = null } = {}) {
    const dx = target.x - this.x;
    const dy = target.y - this.y;

    let nx = right ? dy : -dy;
    let ny = right ? -dx : dx;

    const nlen = Math.hypot(nx, ny);
    if (nlen) {
      const L = length == null ? Math.hypot(dx, dy) : length;
      nx = nx * (L / nlen);
      ny = ny * (L / nlen);
    }

    return new Vector(this.x + nx, this.y + ny);
  }

  static add(a, b) {
    return new Vector(a.x + b.x, a.y + b.y);
  }

  static sub(a, b) {
    return new Vector(a.x - b.x, a.y - b.y);
  }

  static mult(a, b) {
    return new Vector(a.x * b.x, a.y * b.y);
  }

  static div(a, b) {
    return new Vector(a.x / b.x, a.y / b.y);
  }

  static dot(a, b) {
    return a.x * b.x + a.y * b.y;
  }

  static cross(a, b) {
    return a.x * b.y - a.y * b.x;
  }

  static signBetween(v1, v2) {
    return Math.sign(v1.x * v2.y - v1.y * v2.x);
  }

  static angleBetween(v1, v2) {
    const m1 = v1.mag();
    const m2 = v2.mag();
    if (m1 === 0 || m2 === 0) return 0;
    let amt = v1.dot(v2) / (m1 * m2);
    amt = Math.min(1, Math.max(-1, amt));
    return Math.acos(amt);
  }

  static signedAngleBetween(v1, v2) {
    const dot = v1.dot(v2);
    const cross = v1.cross(v2);
    return Math.atan2(cross, dot);
  }

  //법선
  static perp(v) {
    return new Vector(-v.y, v.x);
  }
  static perpBetween(v1, v2, { right = false, length = null } = {}) {
    const dx = v2.x - v1.x;
    const dy = v2.y - v1.y;

    let nx = right ? dy : -dy;
    let ny = right ? -dx : dx;

    const nlen = Math.hypot(nx, ny);
    if (nlen) {
      const L = length == null ? Math.hypot(dx, dy) : length;
      nx = nx * (L / nlen);
      ny = ny * (L / nlen);
    }
    return new Vector(v1.x + nx, v1.y + ny);
  }

  //투영
  //v2에 대한 v1의...
  static scalarProject(v1, v2) {
    const m = v2.mag();
    if (m === 0) return 0;
    return v1.dot(v2) / m;
  }
  static project(a, b) {
    const m2 = b.mag() ** 2;
    if (m2 === 0) return new Vector(0, 0);
    const scalar = a.dot(b) / m2;
    return new Vector(b.x * scalar, b.y * scalar);
  }
  static projectOnLine(v, a, b) {
    const av = Vector.sub(v, a);
    const ab = Vector.sub(b, a);
    const m2 = ab.magSq();
    if (m2 === 0) return a.copy();
    const t = av.dot(ab) / m2;
    return new Vector(a.x + ab.x * t, a.y + ab.y * t);
  }
  static projectOnSegment(v, a, b) {
    const av = Vector.sub(v, a);
    const ab = Vector.sub(b, a);
    const m2 = ab.magSq();
    if (m2 === 0) return a.copy();
    let t = av.dot(ab) / m2;
    t = Math.max(0, Math.min(1, t));
    return new Vector(a.x + ab.x * t, a.y + ab.y * t);
  }

  //반사
  static reflect(v, n) {
    const nn = n.copy().normalize();
    const k = 2 * v.dot(nn);
    return new Vector(v.x - k * nn.x, v.y - k * nn.y);
  }
  static reflectOnLine(v, a, b) {
    // const ab = Vector.sub(b, a);
    // if (ab.magSq() === 0) return v.copy();
    const p = Vector.projectOnLine(v, a, b);
    return new Vector(2 * p.x - v.x, 2 * p.y - v.y);
  }
  static reflectOnLine2(v, a, b) {
    // const ab = Vector.sub(b, a);
    // if (ab.magSq() === 0) return v.copy();
    const mid = Vector.add(a, b).mult(0.5);
    const pap = this.perpBetween(mid, b, { length: 1 });
    const p = Vector.reflectOnLine(v, mid, pap);
    return p;
  }

  static dist(v1, v2) {
    const dx = v1.x - v2.x;
    const dy = v1.y - v2.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  static lerp(v1, v2, t) {
    const x = v1.x + (v2.x - v1.x) * t;
    const y = v1.y + (v2.y - v1.y) * t;
    return new Vector(x, y);
  }
}

// functions
function vector2(x, y) {
  return new Vector(x, y);
}

type vectorModule_Vector = Vector;
declare const vectorModule_Vector: typeof Vector;
declare const vectorModule_vector2: typeof vector2;
declare namespace vectorModule {
  export { vectorModule_Vector as Vector, vectorModule_vector2 as vector2 };
}

// src/index.js

function vector(x, y) {
  return new Vector(x, y);
}

Object.assign(vector, vectorModule);

export { Vector, vector as default, vector2 };
